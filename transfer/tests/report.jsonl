{"pytest_version": "7.2.0", "$report_type": "SessionStart"}
{"nodeid": "", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "$report_type": "CollectReport"}
{"nodeid": "tests/test_test_alice_zero_violation1.py", "outcome": "passed", "longrepr": null, "result": null, "sections": [], "$report_type": "CollectReport"}
{"nodeid": "tests/test_test_alice_zero_violation1.py::test_test_alice_zero_violation1", "location": ["../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/modelator/pytest/decorators.py", 85, "test_test_alice_zero_violation1"], "keywords": {"test_test_alice_zero_violation1": 1, "usefixtures": 1, "pytestmark": 1, "tests/test_test_alice_zero_violation1.py": 1, "transfer": 1}, "outcome": "passed", "longrepr": null, "when": "setup", "user_properties": [], "sections": [], "duration": 0.00036718799674417824, "$report_type": "TestReport"}
{"nodeid": "tests/test_test_alice_zero_violation1.py::test_test_alice_zero_violation1", "location": ["../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/modelator/pytest/decorators.py", 85, "test_test_alice_zero_violation1"], "keywords": {"test_test_alice_zero_violation1": 1, "usefixtures": 1, "pytestmark": 1, "tests/test_test_alice_zero_violation1.py": 1, "transfer": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "/home/philip/.pyenv/versions/3.10.6/lib/python3.10/subprocess.py", "lineno": 1845, "message": "FileNotFoundError: [Errno 2] No such file or directory: 'simd'"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    @pytest.mark.usefixtures(*step_fixtures)", "    def wrapper(request: FixtureRequest):", "        for step in trace:", "            try:", "                if keypath is None:", "                    step_func = request.getfixturevalue(\"mbt_step\")", "                else:", "                    step_func = request.getfixturevalue(", "                        f\"mbt_{dict_get_keypath(step, keypath)}\"", "                    )", "                # prepare the kwargs for this method", "                # if the argument is a ITF trace variable, read it from step", "                # else it is a fixture", "                kwargs = {", "                    arg: step[arg] if arg in step else request.getfixturevalue(arg)", "                    for arg in get_args(step_func)", "                }", ">               step_func(**kwargs)"], "reprfuncargs": {"args": [["request", "<FixtureRequest for <Function test_test_alice_zero_violation1>>"]]}, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/modelator/pytest/decorators.py", "lineno": 103, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    testnet.oneshot()"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "reactors/reactor.py", "lineno": 15, "message": "in init"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    self.prepare()"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/atomkraft/chain/testnet.py", "lineno": 327, "message": "in oneshot"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    node.init()"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/atomkraft/chain/testnet.py", "lineno": 208, "message": "in prepare"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self._json_from_stdout_or_stderr(*self._execute(argstr.split()))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/atomkraft/chain/node.py", "lineno": 129, "message": "in init"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    with Popen(final_args, stdin=stdin_pipe, stdout=stdout, stderr=stderr) as p:"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/atomkraft/chain/node.py", "lineno": 237, "message": "in _execute"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    self._execute_child(args, executable, preexec_fn, close_fds,"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/subprocess.py", "lineno": 969, "message": "in __init__"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _execute_child(self, args, executable, preexec_fn, close_fds,", "                       pass_fds, cwd, env,", "                       startupinfo, creationflags, shell,", "                       p2cread, p2cwrite,", "                       c2pread, c2pwrite,", "                       errread, errwrite,", "                       restore_signals,", "                       gid, gids, uid, umask,", "                       start_new_session):", "        \"\"\"Execute program (POSIX version)\"\"\"", "    ", "        if isinstance(args, (str, bytes)):", "            args = [args]", "        elif isinstance(args, os.PathLike):", "            if shell:", "                raise TypeError('path-like args is not allowed when '", "                                'shell is true')", "            args = [args]", "        else:", "            args = list(args)", "    ", "        if shell:", "            # On Android the default shell is at '/system/bin/sh'.", "            unix_shell = ('/system/bin/sh' if", "                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')", "            args = [unix_shell, \"-c\"] + args", "            if executable:", "                args[0] = executable", "    ", "        if executable is None:", "            executable = args[0]", "    ", "        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)", "    ", "        if (_USE_POSIX_SPAWN", "                and os.path.dirname(executable)", "                and preexec_fn is None", "                and not close_fds", "                and not pass_fds", "                and cwd is None", "                and (p2cread == -1 or p2cread > 2)", "                and (c2pwrite == -1 or c2pwrite > 2)", "                and (errwrite == -1 or errwrite > 2)", "                and not start_new_session", "                and gid is None", "                and gids is None", "                and uid is None", "                and umask < 0):", "            self._posix_spawn(args, executable, env, restore_signals,", "                              p2cread, p2cwrite,", "                              c2pread, c2pwrite,", "                              errread, errwrite)", "            return", "    ", "        orig_executable = executable", "    ", "        # For transferring possible exec failure from child to parent.", "        # Data format: \"exception name:hex errno:description\"", "        # Pickle is not used; it is complex and involves memory allocation.", "        errpipe_read, errpipe_write = os.pipe()", "        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.", "        low_fds_to_close = []", "        while errpipe_write < 3:", "            low_fds_to_close.append(errpipe_write)", "            errpipe_write = os.dup(errpipe_write)", "        for low_fd in low_fds_to_close:", "            os.close(low_fd)", "        try:", "            try:", "                # We must avoid complex work that could involve", "                # malloc or free in the child process to avoid", "                # potential deadlocks, thus we do all this here.", "                # and pass it to fork_exec()", "    ", "                if env is not None:", "                    env_list = []", "                    for k, v in env.items():", "                        k = os.fsencode(k)", "                        if b'=' in k:", "                            raise ValueError(\"illegal environment variable name\")", "                        env_list.append(k + b'=' + os.fsencode(v))", "                else:", "                    env_list = None  # Use execv instead of execve.", "                executable = os.fsencode(executable)", "                if os.path.dirname(executable):", "                    executable_list = (executable,)", "                else:", "                    # This matches the behavior of os._execvpe().", "                    executable_list = tuple(", "                        os.path.join(os.fsencode(dir), executable)", "                        for dir in os.get_exec_path(env))", "                fds_to_keep = set(pass_fds)", "                fds_to_keep.add(errpipe_write)", "                self.pid = _posixsubprocess.fork_exec(", "                        args, executable_list,", "                        close_fds, tuple(sorted(map(int, fds_to_keep))),", "                        cwd, env_list,", "                        p2cread, p2cwrite, c2pread, c2pwrite,", "                        errread, errwrite,", "                        errpipe_read, errpipe_write,", "                        restore_signals, start_new_session,", "                        gid, gids, uid, umask,", "                        preexec_fn)", "                self._child_created = True", "            finally:", "                # be sure the FD is closed no matter what", "                os.close(errpipe_write)", "    ", "            self._close_pipe_fds(p2cread, p2cwrite,", "                                 c2pread, c2pwrite,", "                                 errread, errwrite)", "    ", "            # Wait for exec to fail or succeed; possibly raising an", "            # exception (limited in size)", "            errpipe_data = bytearray()", "            while True:", "                part = os.read(errpipe_read, 50000)", "                errpipe_data += part", "                if not part or len(errpipe_data) > 50000:", "                    break", "        finally:", "            # be sure the FD is closed no matter what", "            os.close(errpipe_read)", "    ", "        if errpipe_data:", "            try:", "                pid, sts = os.waitpid(self.pid, 0)", "                if pid == self.pid:", "                    self._handle_exitstatus(sts)", "                else:", "                    self.returncode = sys.maxsize", "            except ChildProcessError:", "                pass", "    ", "            try:", "                exception_name, hex_errno, err_msg = (", "                        errpipe_data.split(b':', 2))", "                # The encoding here should match the encoding", "                # written in by the subprocess implementations", "                # like _posixsubprocess", "                err_msg = err_msg.decode()", "            except ValueError:", "                exception_name = b'SubprocessError'", "                hex_errno = b'0'", "                err_msg = 'Bad exception data from child: {!r}'.format(", "                              bytes(errpipe_data))", "            child_exception_type = getattr(", "                    builtins, exception_name.decode('ascii'),", "                    SubprocessError)", "            if issubclass(child_exception_type, OSError) and hex_errno:", "                errno_num = int(hex_errno, 16)", "                child_exec_never_called = (err_msg == \"noexec\")", "                if child_exec_never_called:", "                    err_msg = \"\"", "                    # The error must be from chdir(cwd).", "                    err_filename = cwd", "                else:", "                    err_filename = orig_executable", "                if errno_num != 0:", "                    err_msg = os.strerror(errno_num)", ">               raise child_exception_type(errno_num, err_msg, err_filename)", "E               FileNotFoundError: [Errno 2] No such file or directory: 'simd'"], "reprfuncargs": {"args": [["self", "<Popen: returncode: 255 args: ['simd', '--home', '/home/philip/atomkraft/tra...>"], ["args", "['simd', '--home', '/home/philip/atomkraft/transfer/.atomkraft/validator_nodes/val_qgwovedy/node_0', 'init', 'node_0', '--chain-id', ...]"], ["executable", "b'simd'"], ["preexec_fn", "None"], ["close_fds", "True"], ["pass_fds", "()"], ["cwd", "None"], ["env", "None"], ["startupinfo", "None"], ["creationflags", "0"], ["shell", "False"], ["p2cread", "-1"], ["p2cwrite", "-1"], ["c2pread", "-1"], ["c2pwrite", "-1"], ["errread", "-1"], ["errwrite", "-1"], ["restore_signals", "True"], ["gid", "None"], ["gids", "None"], ["uid", "None"], ["umask", "-1"], ["start_new_session", "False"]]}, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/subprocess.py", "lineno": 1845, "message": "FileNotFoundError"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    @pytest.mark.usefixtures(*step_fixtures)", "    def wrapper(request: FixtureRequest):", "        for step in trace:", "            try:", "                if keypath is None:", "                    step_func = request.getfixturevalue(\"mbt_step\")", "                else:", "                    step_func = request.getfixturevalue(", "                        f\"mbt_{dict_get_keypath(step, keypath)}\"", "                    )", "                # prepare the kwargs for this method", "                # if the argument is a ITF trace variable, read it from step", "                # else it is a fixture", "                kwargs = {", "                    arg: step[arg] if arg in step else request.getfixturevalue(arg)", "                    for arg in get_args(step_func)", "                }", ">               step_func(**kwargs)"], "reprfuncargs": {"args": [["request", "<FixtureRequest for <Function test_test_alice_zero_violation1>>"]]}, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/modelator/pytest/decorators.py", "lineno": 103, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    testnet.oneshot()"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "reactors/reactor.py", "lineno": 15, "message": "in init"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    self.prepare()"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/atomkraft/chain/testnet.py", "lineno": 327, "message": "in oneshot"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    node.init()"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/atomkraft/chain/testnet.py", "lineno": 208, "message": "in prepare"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return self._json_from_stdout_or_stderr(*self._execute(argstr.split()))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/atomkraft/chain/node.py", "lineno": 129, "message": "in init"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    with Popen(final_args, stdin=stdin_pipe, stdout=stdout, stderr=stderr) as p:"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/atomkraft/chain/node.py", "lineno": 237, "message": "in _execute"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    self._execute_child(args, executable, preexec_fn, close_fds,"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/subprocess.py", "lineno": 969, "message": "in __init__"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _execute_child(self, args, executable, preexec_fn, close_fds,", "                       pass_fds, cwd, env,", "                       startupinfo, creationflags, shell,", "                       p2cread, p2cwrite,", "                       c2pread, c2pwrite,", "                       errread, errwrite,", "                       restore_signals,", "                       gid, gids, uid, umask,", "                       start_new_session):", "        \"\"\"Execute program (POSIX version)\"\"\"", "    ", "        if isinstance(args, (str, bytes)):", "            args = [args]", "        elif isinstance(args, os.PathLike):", "            if shell:", "                raise TypeError('path-like args is not allowed when '", "                                'shell is true')", "            args = [args]", "        else:", "            args = list(args)", "    ", "        if shell:", "            # On Android the default shell is at '/system/bin/sh'.", "            unix_shell = ('/system/bin/sh' if", "                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')", "            args = [unix_shell, \"-c\"] + args", "            if executable:", "                args[0] = executable", "    ", "        if executable is None:", "            executable = args[0]", "    ", "        sys.audit(\"subprocess.Popen\", executable, args, cwd, env)", "    ", "        if (_USE_POSIX_SPAWN", "                and os.path.dirname(executable)", "                and preexec_fn is None", "                and not close_fds", "                and not pass_fds", "                and cwd is None", "                and (p2cread == -1 or p2cread > 2)", "                and (c2pwrite == -1 or c2pwrite > 2)", "                and (errwrite == -1 or errwrite > 2)", "                and not start_new_session", "                and gid is None", "                and gids is None", "                and uid is None", "                and umask < 0):", "            self._posix_spawn(args, executable, env, restore_signals,", "                              p2cread, p2cwrite,", "                              c2pread, c2pwrite,", "                              errread, errwrite)", "            return", "    ", "        orig_executable = executable", "    ", "        # For transferring possible exec failure from child to parent.", "        # Data format: \"exception name:hex errno:description\"", "        # Pickle is not used; it is complex and involves memory allocation.", "        errpipe_read, errpipe_write = os.pipe()", "        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.", "        low_fds_to_close = []", "        while errpipe_write < 3:", "            low_fds_to_close.append(errpipe_write)", "            errpipe_write = os.dup(errpipe_write)", "        for low_fd in low_fds_to_close:", "            os.close(low_fd)", "        try:", "            try:", "                # We must avoid complex work that could involve", "                # malloc or free in the child process to avoid", "                # potential deadlocks, thus we do all this here.", "                # and pass it to fork_exec()", "    ", "                if env is not None:", "                    env_list = []", "                    for k, v in env.items():", "                        k = os.fsencode(k)", "                        if b'=' in k:", "                            raise ValueError(\"illegal environment variable name\")", "                        env_list.append(k + b'=' + os.fsencode(v))", "                else:", "                    env_list = None  # Use execv instead of execve.", "                executable = os.fsencode(executable)", "                if os.path.dirname(executable):", "                    executable_list = (executable,)", "                else:", "                    # This matches the behavior of os._execvpe().", "                    executable_list = tuple(", "                        os.path.join(os.fsencode(dir), executable)", "                        for dir in os.get_exec_path(env))", "                fds_to_keep = set(pass_fds)", "                fds_to_keep.add(errpipe_write)", "                self.pid = _posixsubprocess.fork_exec(", "                        args, executable_list,", "                        close_fds, tuple(sorted(map(int, fds_to_keep))),", "                        cwd, env_list,", "                        p2cread, p2cwrite, c2pread, c2pwrite,", "                        errread, errwrite,", "                        errpipe_read, errpipe_write,", "                        restore_signals, start_new_session,", "                        gid, gids, uid, umask,", "                        preexec_fn)", "                self._child_created = True", "            finally:", "                # be sure the FD is closed no matter what", "                os.close(errpipe_write)", "    ", "            self._close_pipe_fds(p2cread, p2cwrite,", "                                 c2pread, c2pwrite,", "                                 errread, errwrite)", "    ", "            # Wait for exec to fail or succeed; possibly raising an", "            # exception (limited in size)", "            errpipe_data = bytearray()", "            while True:", "                part = os.read(errpipe_read, 50000)", "                errpipe_data += part", "                if not part or len(errpipe_data) > 50000:", "                    break", "        finally:", "            # be sure the FD is closed no matter what", "            os.close(errpipe_read)", "    ", "        if errpipe_data:", "            try:", "                pid, sts = os.waitpid(self.pid, 0)", "                if pid == self.pid:", "                    self._handle_exitstatus(sts)", "                else:", "                    self.returncode = sys.maxsize", "            except ChildProcessError:", "                pass", "    ", "            try:", "                exception_name, hex_errno, err_msg = (", "                        errpipe_data.split(b':', 2))", "                # The encoding here should match the encoding", "                # written in by the subprocess implementations", "                # like _posixsubprocess", "                err_msg = err_msg.decode()", "            except ValueError:", "                exception_name = b'SubprocessError'", "                hex_errno = b'0'", "                err_msg = 'Bad exception data from child: {!r}'.format(", "                              bytes(errpipe_data))", "            child_exception_type = getattr(", "                    builtins, exception_name.decode('ascii'),", "                    SubprocessError)", "            if issubclass(child_exception_type, OSError) and hex_errno:", "                errno_num = int(hex_errno, 16)", "                child_exec_never_called = (err_msg == \"noexec\")", "                if child_exec_never_called:", "                    err_msg = \"\"", "                    # The error must be from chdir(cwd).", "                    err_filename = cwd", "                else:", "                    err_filename = orig_executable", "                if errno_num != 0:", "                    err_msg = os.strerror(errno_num)", ">               raise child_exception_type(errno_num, err_msg, err_filename)", "E               FileNotFoundError: [Errno 2] No such file or directory: 'simd'"], "reprfuncargs": {"args": [["self", "<Popen: returncode: 255 args: ['simd', '--home', '/home/philip/atomkraft/tra...>"], ["args", "['simd', '--home', '/home/philip/atomkraft/transfer/.atomkraft/validator_nodes/val_qgwovedy/node_0', 'init', 'node_0', '--chain-id', ...]"], ["executable", "b'simd'"], ["preexec_fn", "None"], ["close_fds", "True"], ["pass_fds", "()"], ["cwd", "None"], ["env", "None"], ["startupinfo", "None"], ["creationflags", "0"], ["shell", "False"], ["p2cread", "-1"], ["p2cwrite", "-1"], ["c2pread", "-1"], ["c2pwrite", "-1"], ["errread", "-1"], ["errwrite", "-1"], ["restore_signals", "True"], ["gid", "None"], ["gids", "None"], ["uid", "None"], ["umask", "-1"], ["start_new_session", "False"]]}, "reprlocals": null, "reprfileloc": {"path": "../../.pyenv/versions/3.10.6/lib/python3.10/subprocess.py", "lineno": 1845, "message": "FileNotFoundError"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "/home/philip/.pyenv/versions/3.10.6/lib/python3.10/subprocess.py", "lineno": 1845, "message": "FileNotFoundError: [Errno 2] No such file or directory: 'simd'"}, null]]}, "when": "call", "user_properties": [], "sections": [["Captured log call", "\u001b[32mINFO    \u001b[0m root:reactor.py:11 Step: Init"]], "duration": 0.0924298350000754, "$report_type": "TestReport"}
{"nodeid": "tests/test_test_alice_zero_violation1.py::test_test_alice_zero_violation1", "location": ["../../.pyenv/versions/3.10.6/lib/python3.10/site-packages/modelator/pytest/decorators.py", 85, "test_test_alice_zero_violation1"], "keywords": {"test_test_alice_zero_violation1": 1, "usefixtures": 1, "pytestmark": 1, "tests/test_test_alice_zero_violation1.py": 1, "transfer": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [["Captured log call", "\u001b[32mINFO    \u001b[0m root:reactor.py:11 Step: Init"]], "duration": 0.0004365069980849512, "$report_type": "TestReport"}
{"exitstatus": 1, "$report_type": "SessionFinish"}
